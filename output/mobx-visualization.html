<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>深入理解MobX响应式系统</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Noto+Sans+SC:wght@300;400;500;700&family=Fira+Code:wght@400;500&display=swap" rel="stylesheet">
    <style>
        :root {
            --color-primary: #0070f3;
            --color-secondary: #6366f1;
            --color-accent: #f59e0b;
            --color-text: #1f2937;
            --color-text-light: #6b7280;
            --color-background: #ffffff;
            --color-background-alt: #f9fafb;
            --color-border: #e5e7eb;
            --color-code-bg: #f3f4f6;
            --color-code-text: #374151;
            --color-success: #10b981;
            --color-warning: #f59e0b;
            --color-error: #ef4444;
        }

        .dark {
            --color-primary: #3b82f6;
            --color-secondary: #818cf8;
            --color-accent: #fbbf24;
            --color-text: #f9fafb;
            --color-text-light: #9ca3af;
            --color-background: #111827;
            --color-background-alt: #1f2937;
            --color-border: #374151;
            --color-code-bg: #1e293b;
            --color-code-text: #e5e7eb;
            --color-success: #059669;
            --color-warning: #d97706;
            --color-error: #dc2626;
        }

        body {
            font-family: 'Inter', 'Noto Sans SC', sans-serif;
            color: var(--color-text);
            background-color: var(--color-background);
            transition: background-color 0.3s, color 0.3s;
        }

        h1, h2, h3, h4, h5, h6 {
            font-family: 'Noto Sans SC', 'Inter', sans-serif;
            font-weight: 600;
        }

        code, pre {
            font-family: 'Fira Code', monospace;
            background-color: var(--color-code-bg);
            color: var(--color-code-text);
            border-radius: 0.375rem;
            transition: background-color 0.3s, color 0.3s;
        }

        pre {
            padding: 1rem;
            overflow-x: auto;
        }

        code {
            padding: 0.125rem 0.25rem;
        }

        .card {
            background-color: var(--color-background);
            border: 1px solid var(--color-border);
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            transition: transform 0.2s, box-shadow 0.2s, border-color 0.3s, background-color 0.3s;
        }

        .card:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            border-color: var(--color-primary);
        }

        .btn {
            transition: transform 0.1s, background-color 0.3s, color 0.3s;
        }

        .btn:hover {
            transform: scale(1.05);
        }

        .btn:active {
            transform: scale(0.98);
        }

        .fade-in {
            animation: fadeIn 0.5s ease-in-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .concept-diagram {
            max-width: 100%;
            height: auto;
            margin: 2rem auto;
        }

        .highlight {
            background: linear-gradient(120deg, rgba(99, 102, 241, 0.2) 0%, rgba(99, 102, 241, 0.1) 100%);
            padding: 0.125rem 0.25rem;
            border-radius: 0.25rem;
            color: var(--color-primary);
            font-weight: 500;
        }

        .dark .highlight {
            background: linear-gradient(120deg, rgba(129, 140, 248, 0.3) 0%, rgba(129, 140, 248, 0.1) 100%);
            color: var(--color-secondary);
        }

        .code-block {
            position: relative;
            margin: 1.5rem 0;
        }

        .code-block .language-label {
            position: absolute;
            top: 0;
            right: 0;
            background-color: var(--color-secondary);
            color: white;
            font-size: 0.75rem;
            padding: 0.25rem 0.5rem;
            border-radius: 0 0.375rem 0 0.375rem;
        }

        .code-block pre {
            padding-top: 2rem;
        }

        .code-annotation {
            display: inline-block;
            margin-left: 0.5rem;
            color: var(--color-success);
            font-weight: 500;
        }

        .code-annotation.warning {
            color: var(--color-warning);
        }

        .code-annotation.error {
            color: var(--color-error);
        }

        .diagram-container {
            position: relative;
            width: 100%;
            height: 0;
            padding-bottom: 56.25%;
            margin: 2rem 0;
        }

        .diagram-container svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .timeline {
            position: relative;
            padding-left: 2rem;
            margin: 2rem 0;
        }

        .timeline::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0.5rem;
            height: 100%;
            width: 2px;
            background-color: var(--color-border);
        }

        .timeline-item {
            position: relative;
            margin-bottom: 1.5rem;
        }

        .timeline-item::before {
            content: '';
            position: absolute;
            left: -2rem;
            top: 0.25rem;
            width: 1rem;
            height: 1rem;
            border-radius: 50%;
            background-color: var(--color-primary);
        }

        .comparison-table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            margin: 2rem 0;
        }

        .comparison-table th,
        .comparison-table td {
            padding: 1rem;
            border: 1px solid var(--color-border);
            text-align: left;
        }

        .comparison-table th {
            background-color: var(--color-background-alt);
            font-weight: 600;
        }

        .comparison-table tr:first-child th:first-child {
            border-top-left-radius: 0.5rem;
        }

        .comparison-table tr:first-child th:last-child {
            border-top-right-radius: 0.5rem;
        }

        .comparison-table tr:last-child td:first-child {
            border-bottom-left-radius: 0.5rem;
        }

        .comparison-table tr:last-child td:last-child {
            border-bottom-right-radius: 0.5rem;
        }

        .book-card {
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        .book-card-image {
            aspect-ratio: 2/3;
            background-color: var(--color-background-alt);
            border-radius: 0.25rem;
            overflow: hidden;
            margin-bottom: 1rem;
        }

        .book-card-image img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .book-card-content {
            flex: 1;
        }

        .book-card-title {
            font-weight: 600;
            margin-bottom: 0.5rem;
        }

        .book-card-author {
            color: var(--color-text-light);
            font-size: 0.875rem;
            margin-bottom: 0.5rem;
        }

        .book-card-description {
            font-size: 0.875rem;
            margin-bottom: 1rem;
        }

        .social-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 2.5rem;
            height: 2.5rem;
            border-radius: 50%;
            background-color: var(--color-background-alt);
            color: var(--color-text);
            transition: background-color 0.3s, color 0.3s, transform 0.2s;
        }

        .social-icon:hover {
            background-color: var(--color-primary);
            color: white;
            transform: translateY(-2px);
        }

        /* 动画效果 */
        .animate-on-scroll {
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.6s, transform 0.6s;
        }

        .animate-on-scroll.visible {
            opacity: 1;
            transform: translateY(0);
        }

        /* 响应式调整 */
        @media (max-width: 640px) {
            .container {
                padding-left: 1rem;
                padding-right: 1rem;
            }
            
            h1 {
                font-size: 1.875rem;
            }
            
            h2 {
                font-size: 1.5rem;
            }
            
            .timeline {
                padding-left: 1.5rem;
            }
            
            .timeline-item::before {
                left: -1.5rem;
            }
        }
    </style>
</head>
<body class="min-h-screen">
    <header class="py-6 border-b border-gray-200 dark:border-gray-700 sticky top-0 bg-white dark:bg-gray-900 z-10 shadow-sm">
        <div class="container mx-auto px-4 sm:px-6 lg:px-8">
            <div class="flex justify-between items-center">
                <h1 class="text-2xl sm:text-3xl font-bold text-gray-900 dark:text-white">
                    <span class="text-blue-600 dark:text-blue-400">MobX</span> 响应式系统深度解析
                </h1>
                <button id="theme-toggle" class="p-2 rounded-full bg-gray-100 dark:bg-gray-800 text-gray-500 dark:text-gray-400 hover:bg-gray-200 dark:hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 dark:focus:ring-offset-gray-900">
                    <svg id="sun-icon" class="w-5 h-5 hidden dark:block" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
                        <path fill-rule="evenodd" d="M10 2a1 1 0 011 1v1a1 1 0 11-2 0V3a1 1 0 011-1zm4 8a4 4 0 11-8 0 4 4 0 018 0zm-.464 4.95l.707.707a1 1 0 001.414-1.414l-.707-.707a1 1 0 00-1.414 1.414zm2.12-10.607a1 1 0 010 1.414l-.706.707a1 1 0 11-1.414-1.414l.707-.707a1 1 0 011.414 0zM17 11a1 1 0 100-2h-1a1 1 0 100 2h1zm-7 4a1 1 0 011 1v1a1 1 0 11-2 0v-1a1 1 0 011-1zM5.05 6.464A1 1 0 106.465 5.05l-.708-.707a1 1 0 00-1.414 1.414l.707.707zm1.414 8.486l-.707.707a1 1 0 01-1.414-1.414l.707-.707a1 1 0 011.414 1.414zM4 11a1 1 0 100-2H3a1 1 0 000 2h1z" clip-rule="evenodd"></path>
                    </svg>
                    <svg id="moon-icon" class="w-5 h-5 block dark:hidden" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
                        <path d="M17.293 13.293A8 8 0 016.707 2.707a8.001 8.001 0 1010.586 10.586z"></path>
                    </svg>
                </button>
            </div>
        </div>
    </header>

    <main class="container mx-auto px-4 sm:px-6 lg:px-8 py-8">
        <section class="mb-16 animate-on-scroll">
            <div class="max-w-3xl mx-auto">
                <div class="prose prose-lg dark:prose-invert mx-auto">
                    <p class="text-xl leading-relaxed mb-6">
                        一个大多数人没有深入认识到的 MobX 使用真相是：<span class="highlight">异步 action 并不会自动触发 React 组件更新</span>，真正的关键在于 observable 数据的变更，而不是 action 本身的执行。
                    </p>
                </div>
            </div>

            <div class="mt-12 bg-blue-50 dark:bg-blue-900/20 rounded-xl p-6 shadow-inner animate-on-scroll">
                <h2 class="text-2xl font-bold mb-4 text-blue-800 dark:text-blue-300">为什么会这样？</h2>
                <p class="text-lg mb-4">
                    MobX 采用响应式的思维模式，它只关心 observable state 何时发生变化，而不关心你是如何修改它的。
                </p>
                <div class="bg-white dark:bg-gray-800 rounded-lg p-5 shadow-md">
                    <p class="font-medium mb-3">很多人以为 runInAction 或 async action 本身就会触发组件更新，但事实是：</p>
                    <ul class="list-disc pl-6 space-y-2">
                        <li>MobX 并不会监听 action 本身的执行，而是监听 action 影响的 observable 数据。</li>
                        <li>如果异步 action 只是等待，但不修改 observable 数据，React 组件不会重新渲染！</li>
                    </ul>
                </div>
            </div>
        </section>

        <section class="mb-16 animate-on-scroll">
            <h2 class="text-3xl font-bold mb-8 text-center">常见误解示例</h2>
            
            <div class="grid md:grid-cols-2 gap-8">
                <div class="card p-6 animate-on-scroll">
                    <h3 class="text-xl font-semibold mb-4 flex items-center">
                        <span class="inline-flex items-center justify-center w-8 h-8 rounded-full bg-green-100 dark:bg-green-900 text-green-500 dark:text-green-300 mr-3">
                            <i class="fas fa-check"></i>
                        </span>
                        正确的做法
                    </h3>
                    <div class="code-block">
                        <div class="language-label">JavaScript</div>
                        <pre><code>const store = observable({
  data: null,
  fetchData: async function () {
    await new Promise((r) => setTimeout(r, 1000));
    runInAction(() => {
      this.data = "新数据";  // 只有这里触发组件更新
    });
  }
});

const MyComponent = observer(() => {
  console.log("组件渲染了"); // 观察是否触发
  return (
    &lt;div>
      &lt;button onClick={store.fetchData}>加载数据&lt;/button>
      &lt;p>{store.data}&lt;/p>
    &lt;/div>
  );
});</code></pre>
                    </div>
                    <p class="mt-4 text-green-600 dark:text-green-400">
                        ✅ 这个代码是对的，因为 <code>this.data = "新数据"</code> 发生在 <code>runInAction</code> 里，触发了 observable 的变化，从而更新 React 组件。
                    </p>
                </div>

                <div class="card p-6 animate-on-scroll">
                    <h3 class="text-xl font-semibold mb-4 flex items-center">
                        <span class="inline-flex items-center justify-center w-8 h-8 rounded-full bg-red-100 dark:bg-red-900 text-red-500 dark:text-red-300 mr-3">
                            <i class="fas fa-times"></i>
                        </span>
                        错误的做法
                    </h3>
                    <div class="code-block">
                        <div class="language-label">JavaScript</div>
                        <pre><code>const store = observable({
  data: null,
  fetchData: async function () {
    await new Promise((r) => setTimeout(r, 1000));
    this.data = "新数据";  // ❌ 这里不是在 `runInAction` 里
  }
});</code></pre>
                    </div>
                    <p class="mt-4 text-red-600 dark:text-red-400">
                        ❌ 这个时候 data 可能不会被正确追踪，React 组件可能不会更新（特别是 strict mode 下）。
                    </p>
                </div>
            </div>
        </section>

        <section class="mb-16 animate-on-scroll">
            <div class="max-w-4xl mx-auto">
                <h2 class="text-3xl font-bold mb-8 text-center">MobX 响应式系统的核心原理</h2>
                
                <div class="diagram-container animate-on-scroll">
                    <svg viewBox="0 0 800 450" xmlns="http://www.w3.org/2000/svg">
                        <defs>
                            <linearGradient id="flow-gradient" x1="0%" y1="0%" x2="100%" y2="0%">
                                <stop offset="0%" stop-color="#3b82f6" />
                                <stop offset="100%" stop-color="#6366f1" />
                            </linearGradient>
                            <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                                <polygon points="0 0, 10 3.5, 0 7" fill="#6366f1" />
                            </marker>
                        </defs>
                        
                        <!-- Observable Store -->
                        <rect x="100" y="100" width="180" height="120" rx="10" fill="#f0f9ff" stroke="#3b82f6" stroke-width="2" class="dark:fill-gray-800 dark:stroke-blue-500" />
                        <text x="190" y="130" text-anchor="middle" font-size="18" font-weight="bold" fill="#1e40af" class="dark:fill-blue-300">Observable Store</text>
                        <rect x="120" y="150" width="140" height="50" rx="5" fill="#dbeafe" stroke="#3b82f6" stroke-width="1" class="dark:fill-gray-700 dark:stroke-blue-400" />
                        <text x="190" y="180" text-anchor="middle" font-size="14" fill="#1e40af" class="dark:fill-blue-300">count: 0</text>
                        
                        <!-- Action -->
                        <rect x="100" y="300" width="180" height="80" rx="10" fill="#f0f9ff" stroke="#3b82f6" stroke-width="2" class="dark:fill-gray-800 dark:stroke-blue-500" />
                        <text x="190" y="340" text-anchor="middle" font-size="16" font-weight="bold" fill="#1e40af" class="dark:fill-blue-300">Action: increment()</text>
                        
                        <!-- React Component -->
                        <rect x="520" y="100" width="180" height="120" rx="10" fill="#f0f9ff" stroke="#3b82f6" stroke-width="2" class="dark:fill-gray-800 dark:stroke-blue-500" />
                        <text x="610" y="130" text-anchor="middle" font-size="18" font-weight="bold" fill="#1e40af" class="dark:fill-blue-300">React Component</text>
                        <rect x="540" y="150" width="140" height="50" rx="5" fill="#dbeafe" stroke="#3b82f6" stroke-width="1" class="dark:fill-gray-700 dark:stroke-blue-400" />
                        <text x="610" y="180" text-anchor="middle" font-size="14" fill="#1e40af" class="dark:fill-blue-300">observer()</text>
                        
                        <!-- MobX Tracking System -->
                        <rect x="310" y="180" width="180" height="100" rx="10" fill="#eff6ff" stroke="#6366f1" stroke-width="2" class="dark:fill-gray-800 dark:stroke-indigo-500" />
                        <text x="400" y="210" text-anchor="middle" font-size="16" font-weight="bold" fill="#4f46e5" class="dark:fill-indigo-300">MobX 依赖追踪</text>
                        <text x="400" y="240" text-anchor="middle" font-size="14" fill="#4f46e5" class="dark:fill-indigo-300">Reaction System</text>
                        <text x="400" y="260" text-anchor="middle" font-size="14" fill="#4f46e5" class="dark:fill-indigo-300">Dependency Graph</text>
                        
                        <!-- Arrows -->
                        <path d="M190 220 L190 300" stroke="#6366f1" stroke-width="3" stroke-dasharray="5,5" marker-end="url(#arrowhead)" class="dark:stroke-indigo-400" />
                        <text x="150" y="260" font-size="14" fill="#4f46e5" class="dark:fill-indigo-300">修改数据</text>
                        
                        <path d="M280 160 L310 200" stroke="#6366f1" stroke-width="3" marker-end="url(#arrowhead)" class="dark:stroke-indigo-400" />
                        <text x="270" y="190" font-size="14" fill="#4f46e5" class="dark:fill-indigo-300">被追踪</text>
                        
                        <path d="M490 220 L520 160" stroke="#6366f1" stroke-width="3" marker-end="url(#arrowhead)" class="dark:stroke-indigo-400" />
                        <text x="510" y="200" font-size="14" fill="#4f46e5" class="dark:fill-indigo-300">通知更新</text>
                        
                        <path d="M610 220 C610 280 400 320 400 280" stroke="#6366f1" stroke-width="3" stroke-dasharray="5,5" class="dark:stroke-indigo-400" />
                        <text x="500" y="300" font-size="14" fill="#4f46e5" class="dark:fill-indigo-300">读取数据时建立依赖</text>
                        
                        <!-- Data Flow -->
                        <path d="M190 80 C400 30 610 80 610 100" stroke="url(#flow-gradient)" stroke-width="4" fill="none" />
                        <text x="400" y="60" text-anchor="middle" font-size="16" font-weight="bold" fill="#4f46e5" class="dark:fill-indigo-300">数据流动 (Data Flow)</text>
                    </svg>
                </div>
                
                <div class="mt-12 grid md:grid-cols-3 gap-6">
                    <div class="card p-6 animate-on-scroll">
                        <div class="text-center mb-4">
                            <span class="inline-flex items-center justify-center w-12 h-12 rounded-full bg-blue-100 dark:bg-blue-900 text-blue-600 dark:text-blue-300 text-xl">
                                <i class="fas fa-eye"></i>
                            </span>
                        </div>
                        <h3 class="text-xl font-semibold mb-3 text-center">MobX 追踪 observable 依赖</h3>
                        <p>
                            当 React 组件渲染时，如果它"读取"了一个 observable 数据，MobX 就会在后台记录这个依赖关系。只有当这些依赖变化时，组件才会重新渲染。
                        </p>
                    </div>
                    
                    <div class="card p-6 animate-on-scroll">
                        <div class="text-center mb-4">
                            <span class="inline-flex items-center justify-center w-12 h-12 rounded-full bg-indigo-100 dark:bg-indigo-900 text-indigo-600 dark:text-indigo-300 text-xl">
                                <i class="fas fa-sync-alt"></i>
                            </span>
                        </div>
                        <h3 class="text-xl font-semibold mb-3 text-center">observer 高阶组件的作用</h3>
                        <p>
                            observer 让 React 组件变成"响应式组件"，自动追踪组件渲染时访问的 observable，并在 observable 变更时重新渲染组件。
                        </p>
                    </div>
                    
                    <div class="card p-6 animate-on-scroll">
                        <div class="text-center mb-4">
                            <span class="inline-flex items-center justify-center w-12 h-12 rounded-full bg-purple-100 dark:bg-purple-900 text-purple-600 dark:text-purple-300 text-xl">
                                <i class="fas fa-code-branch"></i>
                            </span>
                        </div>
                        <h3 class="text-xl font-semibold mb-3 text-center">异步 action 和 runInAction</h3>
                        <p>
                            MobX 不会自动追踪异步操作，必须确保 observable 变更发生在 MobX 追踪的上下文中，这就是为什么需要 runInAction。
                        </p>
                    </div>
                </div>
            </div>
        </section>

        <section class="mb-16 animate-on-scroll">
            <div class="max-w-4xl mx-auto">
                <h2 class="text-3xl font-bold mb-8 text-center">MobX vs Redux：思维模式对比</h2>
                
                <div class="overflow-hidden rounded-xl shadow-lg animate-on-scroll">
                    <table class="comparison-table">
                        <thead>
                            <tr>
                                <th class="w-1/4">特性</th>
                                <th class="w-3/8">MobX</th>
                                <th class="w-3/8">Redux</th>
                            </tr>
                        </thead>                            <tbody>
                                <tr>
                                    <td>数据流</td>
                                    <td>双向数据流，允许直接修改状态</td>
                                    <td>单向数据流，通过 dispatch action 修改状态</td>
                                </tr>
                                <tr>
                                    <td>状态管理方式</td>
                                    <td>响应式（Reactive）</td>
                                    <td>事件驱动（Event-driven）</td>
                                </tr>
                                <tr>
                                    <td>代码量</td>
                                    <td>较少，更直观</td>
                                    <td>较多，更明确</td>
                                </tr>
                                <tr>
                                    <td>调试难度</td>
                                    <td>中等（依赖追踪有时难以调试）</td>
                                    <td>简单（状态变化有明确的 action 记录）</td>
                                </tr>
                                <tr>
                                    <td>适用场景</td>
                                    <td>中小型应用，快速开发</td>
                                    <td>大型应用，需要严格的状态管理</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>

                    <div class="mt-8 bg-indigo-50 dark:bg-indigo-900/20 p-6 rounded-lg shadow-inner animate-on-scroll">
                        <h3 class="text-xl font-semibold mb-4">核心思想差异</h3>
                        <p class="mb-4">
                            MobX 和 Redux 的最大区别在于思维模式：MobX 是<span class="highlight">响应式编程</span>，而 Redux 是<span class="highlight">函数式编程</span>。
                        </p>
                        <div class="grid md:grid-cols-2 gap-6">
                            <div class="bg-white dark:bg-gray-800 p-4 rounded-lg shadow">
                                <h4 class="font-semibold text-blue-600 dark:text-blue-400 mb-2">MobX 思维模式</h4>
                                <p>
                                    "我只关心数据何时变化，不关心如何变化。当数据变化时，自动更新依赖于这些数据的一切。"
                                </p>
                            </div>
                            <div class="bg-white dark:bg-gray-800 p-4 rounded-lg shadow">
                                <h4 class="font-semibold text-red-600 dark:text-red-400 mb-2">Redux 思维模式</h4>
                                <p>
                                    "状态是只读的，只能通过发送 action 来修改状态，修改过程必须是纯函数。"
                                </p>
                            </div>
                        </div>
                    </div>
                </div>
            </section>

            <section class="mb-16 animate-on-scroll">
                <div class="max-w-4xl mx-auto">
                    <h2 class="text-3xl font-bold mb-8 text-center">MobX 响应式系统常见误区</h2>
                    
                    <div class="timeline animate-on-scroll">
                        <div class="timeline-item">
                            <h3 class="text-xl font-semibold mb-2">误区一：异步 action 自动触发更新</h3>
                            <p class="mb-4">
                                很多开发者误以为只要在 action 中修改了数据，组件就会自动更新，但实际上 MobX 只关心 observable 数据的变化，而不是 action 的执行。
                            </p>
                            <div class="code-block">
                                <div class="language-label">JavaScript</div>
                                <pre><code>// ❌ 错误示例
async function fetchData() {
  const response = await api.getData();
  this.data = response; // 在异步上下文中直接修改，可能不会被追踪
}

// ✅ 正确示例
async function fetchData() {
  const response = await api.getData();
  runInAction(() => {
    this.data = response; // 在 runInAction 中修改，确保被追踪
  });
}</code></pre>
                            </div>
                        </div>
                        
                        <div class="timeline-item">
                            <h3 class="text-xl font-semibold mb-2">误区二：observer 组件总是重新渲染</h3>
                            <p class="mb-4">
                                observer 组件只会在它依赖的 observable 数据变化时重新渲染，而不是在任何 observable 数据变化时都重新渲染。
                            </p>
                            <div class="bg-yellow-50 dark:bg-yellow-900/20 p-4 rounded-lg">
                                <p class="text-yellow-800 dark:text-yellow-300">
                                    <i class="fas fa-lightbulb mr-2"></i>
                                    如果一个 observer 组件没有在渲染过程中读取某个 observable 数据，那么这个数据的变化不会导致组件重新渲染。
                                </p>
                            </div>
                        </div>
                        
                        <div class="timeline-item">
                            <h3 class="text-xl font-semibold mb-2">误区三：computed 值总是最新的</h3>
                            <p class="mb-4">
                                computed 值是惰性计算的，只有在被访问时才会重新计算，如果没有被观察者使用，可能不会更新。
                            </p>
                            <div class="code-block">
                                <div class="language-label">JavaScript</div>
                                <pre><code>const store = observable({
  firstName: "John",
  lastName: "Doe",
  get fullName() {
    console.log("Computing fullName");
    return this.firstName + " " + this.lastName;
  }
});

// 如果没有组件或其他 reaction 使用 fullName
// 即使 firstName 或 lastName 变化了
// fullName 也不会重新计算，直到下次访问它</code></pre>
                            </div>
                        </div>
                        
                        <div class="timeline-item">
                            <h3 class="text-xl font-semibold mb-2">误区四：MobX 自动处理所有异步操作</h3>
                            <p class="mb-4">
                                MobX 不会自动处理异步操作，需要开发者手动确保在正确的上下文中修改 observable 数据。
                            </p>
                            <div class="bg-blue-50 dark:bg-blue-900/20 p-4 rounded-lg">
                                <p>
                                    <strong>最佳实践：</strong> 使用 async/await 结合 runInAction，或者使用 flow 来处理异步操作。
                                </p>
                                <div class="code-block mt-3">
                                    <div class="language-label">JavaScript</div>
                                    <pre><code>// 使用 flow (推荐)
fetchData = flow(function* () {
  try {
    const response = yield api.getData();
    this.data = response; // 自动在正确的上下文中
    this.error = null;
  } catch (error) {
    this.error = error;
  }
});</code></pre>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </section>

            <section class="mb-16 animate-on-scroll">
                <div class="max-w-4xl mx-auto">
                    <h2 class="text-3xl font-bold mb-8 text-center">MobX 最佳实践</h2>
                    
                    <div class="grid md:grid-cols-2 gap-8">
                        <div class="card p-6 animate-on-scroll">
                            <h3 class="text-xl font-semibold mb-4 flex items-center">
                                <span class="inline-flex items-center justify-center w-8 h-8 rounded-full bg-green-100 dark:bg-green-900 text-green-500 dark:text-green-300 mr-3">
                                    <i class="fas fa-check"></i>
                                </span>
                                使用 makeAutoObservable
                            </h3>
                            <p class="mb-4">
                                在 MobX 6 中，推荐使用 makeAutoObservable 来自动推断属性、方法和计算属性的角色。
                            </p>
                            <div class="code-block">
                                <div class="language-label">JavaScript</div>
                                <pre><code>class TodoStore {
  todos = [];
  filter = "all";
  
  constructor() {
    makeAutoObservable(this);
  }
  
  get filteredTodos() {
    // 自动识别为 computed
    switch (this.filter) {
      case "completed":
        return this.todos.filter(t => t.completed);
      case "active":
        return this.todos.filter(t => !t.completed);
      default:
        return this.todos;
    }
  }
  
  addTodo(text) {
    // 自动识别为 action
    this.todos.push({ id: Date.now(), text, completed: false });
  }
}</code></pre>
                            </div>
                        </div>
                        
                        <div class="card p-6 animate-on-scroll">
                            <h3 class="text-xl font-semibold mb-4 flex items-center">
                                <span class="inline-flex items-center justify-center w-8 h-8 rounded-full bg-green-100 dark:bg-green-900 text-green-500 dark:text-green-300 mr-3">
                                    <i class="fas fa-check"></i>
                                </span>
                                使用 flow 处理异步操作
                            </h3>
                            <p class="mb-4">
                                flow 是 MobX 提供的处理异步操作的最佳方式，它使用生成器函数语法，自动在正确的上下文中修改 observable 数据。
                            </p>
                            <div class="code-block">
                                <div class="language-label">JavaScript</div>
                                <pre><code>class UserStore {
  user = null;
  isLoading = false;
  error = null;
  
  constructor() {
    makeAutoObservable(this, {
      fetchUser: flow
    });
  }
  
  // 使用 flow 和生成器函数
  fetchUser = flow(function* (userId) {
    this.isLoading = true;
    try {
      this.user = yield api.fetchUser(userId);
      this.error = null;
    } catch (error) {
      this.error = error;
      this.user = null;
    } finally {
      this.isLoading = false;
    }
  });
}</code></pre>
                            </div>
                        </div>
                        
                        <div class="card p-6 animate-on-scroll">
                            <h3 class="text-xl font-semibold mb-4 flex items-center">
                                <span class="inline-flex items-center justify-center w-8 h-8 rounded-full bg-green-100 dark:bg-green-900 text-green-500 dark:text-green-300 mr-3">
                                    <i class="fas fa-check"></i>
                                </span>
                                使用 reaction 进行副作用管理
                            </h3>
                            <p class="mb-4">
                                reaction 允许你在特定 observable 数据变化时执行副作用，而不是在组件渲染时。
                            </p>
                            <div class="code-block">
                                <div class="language-label">JavaScript</div>
                                <pre><code>// 当 user.preferences 变化时保存到本地存储
reaction(
  () => toJS(user.preferences),
  preferences => {
    localStorage.setItem(
      'preferences', 
      JSON.stringify(preferences)
    );
  }
);

// 当 todos 变化时发送到服务器
reaction(
  () => toJS(todoStore.todos),
  todos => {
    api.saveTodos(todos).catch(error => {
      console.error("Failed to save todos", error);
    });
  }
);</code></pre>
                            </div>
                        </div>
                        
                        <div class="card p-6 animate-on-scroll">
                            <h3 class="text-xl font-semibold mb-4 flex items-center">
                                <span class="inline-flex items-center justify-center w-8 h-8 rounded-full bg-green-100 dark:bg-green-900 text-green-500 dark:text-green-300 mr-3">
                                    <i class="fas fa-check"></i>
                                </span>
                                使用 strict 模式提前发现问题
                            </h3>
                            <p class="mb-4">
                                开启 strict 模式可以帮助你发现在非 action 中修改 observable 数据的问题。
                            </p>
                            <div class="code-block">
                                <div class="language-label">JavaScript</div>
                                <pre><code>// 在应用入口处开启 strict 模式
import { configure } from 'mobx';

configure({
  enforceActions: "always",
  computedRequiresReaction: true,
  reactionRequiresObservable: true,
  observableRequiresReaction: true,
  disableErrorBoundaries: true
});</code></pre>
                            </div>
                            <p class="mt-4 text-gray-600 dark:text-gray-400">
                                这些设置会在开发过程中帮助你发现潜在的问题，但在生产环境中可能需要放宽一些限制。
                            </p>
                        </div>
                    </div>
                </div>
            </section>

            <section class="mb-16 animate-on-scroll">
                <div class="max-w-4xl mx-auto">
                    <h2 class="text-3xl font-bold mb-8 text-center">进一步阅读</h2>
                    
                    <div class="grid md:grid-cols-5 gap-6">
                        <div class="book-card card p-4 animate-on-scroll">
                            <div class="book-card-image">
                                <img src="https://images.unsplash.com/photo-1544716278-ca5e3f4abd8c?ixlib=rb-1.2.1&auto=format&fit=crop&w=300&q=80" alt="Book cover" class="w-full h-full object-cover">
                            </div>
                            <div class="book-card-content">
                                <h3 class="book-card-title">《MobX Quick Start Guide》</h3>
                                <p class="book-card-author">Pavan Podila, Michel Weststrate</p>
                                <p class="book-card-description">由 MobX 创建者共同撰写的官方指南，深入浅出地讲解 MobX 的核心概念和最佳实践。</p>
                            </div>
                        </div>
                        
                        <div class="book-card card p-4 animate-on-scroll">
                            <div class="book-card-image">
                                <img src="https://images.unsplash.com/photo-1532012197267-da84d127e765?ixlib=rb-1.2.1&auto=format&fit=crop&w=300&q=80" alt="Book cover" class="w-full h-full object-cover">
                            </div>
                            <div class="book-card-content">
                                <h3 class="book-card-title">《React Design Patterns and Best Practices》</h3>
                                <p class="book-card-author">Michele Bertoli</p>
                                <p class="book-card-description">探讨 React 生态系统中的设计模式，包括如何有效地使用 MobX 进行状态管理。</p>
                            </div>
                        </div>
                        
                        <div class="book-card card p-4 animate-on-scroll">
                            <div class="book-card-image">
                                <img src="https://images.unsplash.com/photo-1589998059171-988d887df646?ixlib=rb-1.2.1&auto=format&fit=crop&w=300&q=80" alt="Book cover" class="w-full h-full object-cover">
                            </div>
                            <div class="book-card-content">
                                <h3 class="book-card-title">《Reactive Programming with RxJS and MobX》</h3>
                                <p class="book-card-author">Sergey Zhuk</p>
                                <p class="book-card-description">深入探讨响应式编程范式，比较 RxJS 和 MobX 的异同，以及各自的适用场景。</p>
                            </div>
                        </div>
                        
                        <div class="book-card card p-4 animate-on-scroll">
                            <div class="book-card-image">
                                <img src="https://images.unsplash.com/photo-1553729459-efe14ef6055d?ixlib=rb-1.2.1&auto=format&fit=crop&w=300&q=80" alt="Book cover" class="w-full h-full object-cover">
                            </div>
                            <div class="book-card-content">
                                <h3 class="book-card-title">《State Management in React Apps with MobX》</h3>
                                <p class="book-card-author">Michel Weststrate</p>
                                <p class="book-card-description">MobX 创建者的深度指南，专注于在 React 应用中实现高效的状态管理。</p>
                            </div>
                        </div>
                        
                        <div class="book-card card p-4 animate-on-scroll">
                            <div class="book-card-image">
                                <img src="https://images.unsplash.com/photo-1497633762265-9d179a990aa6?ixlib=rb-1.2.1&auto=format&fit=crop&w=300&q=80" alt="Book cover" class="w-full h-full object-cover">
                            </div>
                            <div class="book-card-content">
                                <h3 class="book-card-title">《Functional Reactive Programming》</h3>
                                <p class="book-card-author">Stephen Blackheath, Anthony Jones</p>
                                <p class="book-card-description">探讨函数式响应式编程的理论基础，有助于理解 MobX 等响应式库的底层原理。</p>
                            </div>
                        </div>
                    </div>
                </div>
            </section>
        </main>

        <footer class="bg-gray-100 dark:bg-gray-900 py-12 border-t border-gray-200 dark:border-gray-800">
            <div class="container mx-auto px-4 sm:px-6 lg:px-8">
                <div class="max-w-4xl mx-auto">
                    <div class="flex flex-col md:flex-row justify-between items-center mb-8">
                        <div class="mb-6 md:mb-0">
                            <h2 class="text-2xl font-bold text-gray-900 dark:text-white mb-2">深入理解 MobX 响应式系统</h2>
                            <p class="text-gray-600 dark:text-gray-400">探索 MobX 的响应式原理与最佳实践</p>
                        </div>
                        <div class="flex space-x-4">
                            <a href="https://github.com/yourusername" class="social-icon" target="_blank" rel="noopener noreferrer">
                                <i class="fab fa-github"></i>
                            </a>
                            <a href="https://twitter.com/yourusername" class="social-icon" target="_blank" rel="noopener noreferrer">
                                <i class="fab fa-twitter"></i>
                            </a>
                            <a href="https://linkedin.com/in/yourusername" class="social-icon" target="_blank" rel="noopener noreferrer">
                                <i class="fab fa-linkedin-in"></i>
                            </a>
                        </div>
                    </div>
                    
                    <div class="border-t border-gray-200 dark:border-gray-800 pt-8 text-center">
                        <p class="text-gray-600 dark:text-gray-400">
                            作者：<span class="font-medium text-gray-900 dark:text-white">张三</span>
                        </p>
                        <p class="text-gray-500 dark:text-gray-500 text-sm mt-2">
                            © 2023 版权所有。保留所有权利。
                        </p>
                    </div>
                </div>
            </div>
        </footer>

        <script>
            // 主题切换功能
            const themeToggle = document.getElementById('theme-toggle');
            const htmlElement = document.documentElement;
            
            // 检查系统偏好
            const prefersDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches;
            
            // 检查本地存储中的主题设置
            const savedTheme = localStorage.getItem('theme');
            
            // 设置初始主题
            if (savedTheme) {
                htmlElement.classList.toggle('dark', savedTheme === 'dark');
            } else {
                htmlElement.classList.toggle('dark', prefersDarkMode);
            }
            
            // 主题切换事件
            themeToggle.addEventListener('click', () => {
                htmlElement.classList.toggle('dark');
                const isDark = htmlElement.classList.contains('dark');
                localStorage.setItem('theme', isDark ? 'dark' : 'light');
            });
            
            // 滚动动画
            const animateOnScroll = () => {
                const elements = document.querySelectorAll('.animate-on-scroll');
                
                elements.forEach(element => {
                    const elementTop = element.getBoundingClientRect().top;
                    const elementVisible = 150;
                    
                    if (elementTop < window.innerHeight - elementVisible) {
                        element.classList.add('visible');
                    }
                });
            };
            
            // 初始化滚动动画
            window.addEventListener('scroll', animateOnScroll);
            window.addEventListener('load', animateOnScroll);
            window.addEventListener('resize', animateOnScroll);
            
            // 初始触发一次
            animateOnScroll();
        </script>
    </body>
</html>